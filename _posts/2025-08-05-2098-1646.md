---
layout: post
title: "[2098번] 외판원 순회"
date: 2025-08-05 16:46 +0900
categories: [코딩테스트, C++]
tags: [C++, 알고리즘, 문제풀이]
author: "정준"
thumbnail: 
---

## 문제 설명

![Image](https://github.com/user-attachments/assets/0416113b-9c11-4e62-814e-f728bcd5ca38)

문제 링크: [백준 2098번](https://www.acmicpc.net/problem/2098)

외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.

1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.

N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

---

## 접근 방법

**다이나믹 프로그래밍**\\
**비트마스킹**\\
**비트필드를 이용한 다이나믹 프로그래밍**
**외판원 순회 문제**

dp[now][visited]\\
now: 현재 위치한 도시\\
visited: 지금까지 방문한 도시들의 비트 마스크 (예: 10101)

초반 시작 지점

DP(0, 1 << 0)\\
now = 0: 0번 도시에서 시작\\
visited = 1 << 0: 0번 도시는 방문한 상태\\
즉, 0번에서 출발하며, 0번만 방문한 상태부터 시작하는 것

dp 배열 초기화

왜 -1로 초기화하나?\\
-1은 "아직 계산하지 않은 상태"를 의미\\
실제 최소 비용이 0일 수도 있어서 dp[now][visited] == 0을 초기값으로 쓰면 계산 여부 구분 불가\\
그래서 "미계산"을 구분하기 위해 -1을 사용하는 것\\

---

## 코드 (C++)

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#define INF 987654321

using namespace std;

int N;
int D[16][16];
int dp[16][1 << 16];

int DP(int now, int visited) {
  if (visited == (1 << N) - 1) {
    if (D[now][0] == 0) return INF; // 복귀 불가능하면 큰 값 반환
      return D[now][0]; 
  }
  if (dp[now][visited] != -1) return dp[now][visited];
  
  dp[now][visited] = INF;

  for (int i = 0; i < N; i++) { // 이미 방문한 노드면 패스 
    if (visited & (1 << i)) continue;
    if (D[now][i] == 0) continue; // 경로 없으면 스킵


    int tmp = DP(i, visited | (1 << i));
    dp[now][visited] = min(dp[now][visited], D[now][i] + tmp);
  }
  return dp[now][visited];
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);

  cin >> N;

  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      cin >> D[i][j];
    }
  }

  for (int i = 0; i < N; i++) {
        for (int j = 0; j < (1 << N); j++) {
            dp[i][j] = -1;
        }
    }
 
  cout << DP(0, 1 << 0) << '\n';
}

```

![Image](https://github.com/user-attachments/assets/906325b8-b0dc-4d85-a605-69ce166d944f)